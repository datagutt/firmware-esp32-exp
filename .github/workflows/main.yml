name: Build and Release

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  pull_request:
    branches:
      - "**"

permissions:
  contents: write

jobs:
  quality:
    name: Quality Gates
    runs-on: ubuntu-latest
    container: espressif/idf:latest
    env:
      IDF_CCACHE_ENABLE: "1"

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Git Safe Directory
        run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: Install Host Tooling
        run: |
          . $IDF_PATH/export.sh
          idf_tools.py install esp-clang
          apt-get update
          apt-get install -y --no-install-recommends cppcheck cmake g++

      - name: Build Compile Commands
        run: |
          . $IDF_PATH/export.sh
          idf.py -B build_tidy -D SDKCONFIG_DEFAULTS="sdkconfig.defaults;sdkconfig.defaults.tronbyt-s3" set-target esp32s3
          idf.py -B build_tidy reconfigure

      - name: clang-tidy
        run: |
          . $IDF_PATH/export.sh
          eval "$(idf_tools.py export)"

          # Sanitize GCC-specific flags and add sysroot includes for esp-clang
          python3 << 'PYEOF'
          import json, re, subprocess, os

          # Flags that esp-clang does not understand
          gcc_only = {
              '-mlongcalls', '-fno-malloc-dce', '-fno-tree-switch-conversion',
              '-fstrict-volatile-bitfields', '-fzero-init-padding-bits=all',
              '-mdisable-hardware-atomics', '-Wno-old-style-declaration',
          }

          # Get C++ system include paths from GCC (resolves picolibc.specs)
          proc = subprocess.run(
              ['xtensa-esp32s3-elf-g++', '-mlongcalls', '-specs=picolibc.specs',
               '-E', '-v', '-x', 'c++', '/dev/null'],
              capture_output=True, text=True)
          includes = []
          in_inc = False
          for line in proc.stderr.splitlines():
              if '#include <...> search starts here:' in line:
                  in_inc = True; continue
              if 'End of search list' in line:
                  break
              if in_inc:
                  includes.append(os.path.realpath(line.strip()))

          # Sanitize toolchain response files (cflags, cxxflags)
          for name in ('cflags', 'cxxflags'):
              path = f'build_tidy/toolchain/{name}'
              if not os.path.exists(path):
                  continue
              with open(path) as f:
                  lines = f.readlines()
              with open(path, 'w') as f:
                  for line in lines:
                      flag = line.strip()
                      if flag in gcc_only or flag.startswith('-specs='):
                          continue
                      f.write(line)

          # Sanitize compile_commands.json and inject sysroot includes
          with open('build_tidy/compile_commands.json') as f:
              db = json.load(f)
          isystem_args = ''.join(f' -isystem {p}' for p in includes)
          for entry in db:
              cmd = entry.get('command', '')
              for flag in gcc_only:
                  cmd = cmd.replace(' ' + flag, '')
              entry['command'] = cmd + isystem_args
          with open('build_tidy/compile_commands.json', 'w') as f:
              json.dump(db, f, indent=2)
          print(f'Sanitized compile_commands.json, added {len(includes)} isystem paths')
          PYEOF

          FILES="$(git ls-files 'main/**/*.c' 'main/**/*.cpp' 'components/assets/**/*.c' 'components/assets/**/*.cpp')"
          if [ -z "$FILES" ]; then
            echo "No source files found for clang-tidy"
            exit 1
          fi
          printf '%s\n' "$FILES" | xargs -r -n 25 clang-tidy -p build_tidy \
            --extra-arg=-Wno-unknown-warning-option

      - name: cppcheck
        run: |
          cppcheck --enable=warning,performance,portability \
            --error-exitcode=1 \
            --inline-suppr \
            -I main \
            -I main/network \
            -I main/system \
            main \
            components/assets

      - name: Host Tests
        run: test/host/run_tests.sh

  build:
    name: Build ${{ matrix.target }}
    needs: quality
    runs-on: ubuntu-latest
    container: espressif/idf:latest
    strategy:
      fail-fast: false
      matrix:
        target:
          - tidbyt-gen1
          - tidbyt-gen1_swap
          - tidbyt-gen2
          - tronbyt-s3
          - tronbyt-s3-wide
          - pixoticker
          - matrixportal-s3
          - matrixportal-s3-waveshare

    env:
      IDF_CCACHE_ENABLE: "1"

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Git Safe Directory
        run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: ccache
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: ${{ runner.os }}-ccache-${{ matrix.target }}-${{ hashFiles('**/sdkconfig.defaults*') }}
          restore-keys: |
            ${{ runner.os }}-ccache-${{ matrix.target }}-

      - name: Generate version header
        run: |
          if git describe --tags --abbrev=0 2>/dev/null; then
            VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          else
            VERSION=$(git describe --always --dirty)
          fi
          echo "Firmware version: $VERSION"

          cat > main/version.h << EOF
          // Auto-generated file - DO NOT EDIT
          // Generated by GitHub Actions
          #pragma once
          #define FIRMWARE_VERSION "$VERSION"
          EOF

      - name: Build Target
        run: |
          . $IDF_PATH/export.sh
          target="${{ matrix.target }}"
          echo "--------------------------------------"
          echo "Building target: $target"
          echo "--------------------------------------"

          # Determine chip type based on target
          case "$target" in
            tronbyt-s3*|matrixportal-s3*)
              chip="esp32s3"
              ;;
            *)
              chip="esp32"
              ;;
          esac

          BUILD_DIR="build_$target"

          # Set the target and apply sdkconfig defaults
          idf.py -B "$BUILD_DIR" -D SDKCONFIG_DEFAULTS="sdkconfig.defaults;sdkconfig.defaults.$target" set-target "$chip"
          idf.py -B "$BUILD_DIR" build

          if [ ! -f "$BUILD_DIR/firmware.bin" ]; then
            echo "âŒ Failed to generate firmware for $target"
            exit 1
          fi

          # Generate merged binary
          echo "Generating merged binary for $chip..."
          # Run esptool from within the build directory so relative paths in flash_args work
          (cd "$BUILD_DIR" && python -m esptool --chip "$chip" merge-bin -o "merged_firmware.bin" @flash_args)

          # Rename for artifact upload
          mv "$BUILD_DIR/firmware.bin" "${target}_firmware.bin"
          mv "$BUILD_DIR/merged_firmware.bin" "${target}_merged.bin"

      - name: Size Delta Check
        if: github.event_name == 'pull_request'
        run: |
          . $IDF_PATH/export.sh
          target="${{ matrix.target }}"

          case "$target" in
            tronbyt-s3*|matrixportal-s3*)
              chip="esp32s3"
              ;;
            *)
              chip="esp32"
              ;;
          esac

          BASE_SHA="$(git merge-base HEAD origin/main)"
          if [ -z "$BASE_SHA" ]; then
            echo "No merge-base found; skipping size delta check"
            exit 0
          fi

          WT="/tmp/base-${target}-${BASE_SHA:0:8}"
          git worktree add "$WT" "$BASE_SHA"
          cp secrets.cmake "$WT/secrets.cmake" || true

          pushd "$WT"
          idf.py -B build_base -D SDKCONFIG_DEFAULTS="sdkconfig.defaults;sdkconfig.defaults.$target" set-target "$chip"
          idf.py -B build_base build
          BASE_SIZE=$(stat -c%s build_base/firmware.bin)
          popd

          HEAD_SIZE=$(stat -c%s "${target}_firmware.bin")
          DELTA=$((HEAD_SIZE - BASE_SIZE))
          LIMIT=32768
          echo "Base size: $BASE_SIZE"
          echo "Head size: $HEAD_SIZE"
          echo "Delta: $DELTA bytes (limit: +$LIMIT)"

          git worktree remove "$WT" --force

          if [ "$DELTA" -gt "$LIMIT" ]; then
            echo "Firmware size regression too large for $target: +$DELTA bytes"
            exit 1
          fi

      - name: Upload Artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.target }}_firmware
          path: |
            ${{ matrix.target }}_firmware.bin
            ${{ matrix.target }}_merged.bin
          if-no-files-found: error

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v7
        with:
          path: release-artifacts
          pattern: "*_firmware"
          merge-multiple: true

      - name: Display Artifacts
        run: ls -R release-artifacts/

      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ github.ref_name }}
        run: |
          # Collect all artifacts and pass them to gh release create as positional arguments
          gh release create "$tag" \
              --repo="${GITHUB_REPOSITORY}" \
              --title="${GITHUB_REPOSITORY#*/} ${tag#v}" \
              --generate-notes \
              $(find release-artifacts -type f -print0 | xargs -0)
